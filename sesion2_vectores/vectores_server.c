/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "vectores.h"
#include <stdlib.h>
#include <time.h>

vectores *
initvector_1_svc(datosInit *argp, struct svc_req *rqstp)
{
	static vectores  result;

	xdr_free((xdrproc_t)xdr_vec,(char *)&result);
	result.v1.vec_len = argp->limiteV;
	result.v1.vec_val = malloc(result.v1.vec_len*sizeof(float));
	result.v2.vec_len = argp->limiteV;
	result.v2.vec_val = malloc(result.v2.vec_len*sizeof(float));

	printf("\nVector1 con tama침o: %d \n", result.v1.vec_len);
	//Iniciar con valores aleatorios de 0 a rango (usuario)
	for (int i = 0; i < result.v1.vec_len; i++)
	{
		result.v1.vec_val[i] = (float)rand() / RAND_MAX * argp->rango;
		printf("Elemento %d: %.3f\n", i, result.v1.vec_val[i]);
	}

	printf("\nVector2 con tama침o: %d \n", result.v2.vec_len);
	//Iniciar con valores aleatorios de 0 a rango (usuario)
	for (int i = 0; i < result.v2.vec_len; i++)
	{
		result.v2.vec_val[i] = (float)rand() / RAND_MAX * argp->rango;
		printf("Elemento %d: %.3f\n", i, result.v2.vec_val[i]);
	}
	return &result;
}

vec *
sumavector_1_svc(vectores *argp, struct svc_req *rqstp)
{
	static vec  result;

	result.vec_len = argp->v1.vec_len;
    result.vec_val = malloc(result.vec_len * sizeof(float));

	for (int i = 0; i < result.vec_len; i++) {
        result.vec_val[i] = argp->v1.vec_val[i] + argp->v2.vec_val[i];
		//printf("Posici칩n [%d]: %.3f + %.3f = %.3f\n", (i+1), argp->v1.vec_val[i], argp->v2.vec_val[i], result.vec_val[i]);
    }

	return &result;
}

float *
productoescalar_1_svc(vectores *argp, struct svc_req *rqstp)
{
	static float  result;
	result = 0.0f;

	for (int i = 0; i < argp->v1.vec_len; i++)
	{
		result = result + (argp->v1.vec_val[i] * argp->v2.vec_val[i]);
	}
	
	return &result;
}

vec *
productovectorial_1_svc(vectores *argp, struct svc_req *rqstp)
{
	static vec  result;

	//Solo me va a llamar a esta funci칩n, cuando en el cliente, ambos vectores sean de 3 dimensiones
    result.vec_len = 3;
    result.vec_val = malloc(3 * sizeof(float));

    result.vec_val[0] = argp->v1.vec_val[1] * argp->v2.vec_val[2] - argp->v1.vec_val[2] * argp->v2.vec_val[1];
    result.vec_val[1] = argp->v1.vec_val[2] * argp->v2.vec_val[0] - argp->v1.vec_val[0] * argp->v2.vec_val[2];
    result.vec_val[2] = argp->v1.vec_val[0] * argp->v2.vec_val[1] - argp->v1.vec_val[1] * argp->v2.vec_val[0];

	return &result;
}

vec *
saxpyoperacion_1_svc(vectoresSaxpy *argp, struct svc_req *rqstp)
{
	static vec  result;

	result.vec_len = argp->v1.vec_len;
    result.vec_val = malloc(result.vec_len * sizeof(float));

	for (int i = 0; i < result.vec_len; i++)
	{
		result.vec_val[i] = argp->numero * argp->v1.vec_val[i] + argp->v2.vec_val[i];
	}
	
	return &result;
}
